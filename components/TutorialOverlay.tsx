
import React, { useState, useEffect, useRef } from 'react';
import { X, ChevronRight, ChevronLeft, Zap, Map, Plus, Activity, Save, AlertTriangle } from 'lucide-react';

interface TutorialOverlayProps {
  onClose: () => void;
}

interface Step {
  title: string;
  content: React.ReactNode;
  targetId?: string; // If present, spotlight this element
  position?: 'top' | 'bottom' | 'left' | 'right'; // Preferred position relative to target
  icon?: React.ReactNode;
}

export default function TutorialOverlay({ onClose }: TutorialOverlayProps) {
  const [currentStep, setCurrentStep] = useState(0);
  const [targetRect, setTargetRect] = useState<DOMRect | null>(null);

  const steps: Step[] = [
    {
      title: "SYSTEM INITIALIZED",
      content: (
        <div className="space-y-2">
            <p>Welcome, Administrator. You are now in control of the Sector 7 Metro Network.</p>
            <p>Your directive: Expand the grid, manage resources, and survive the chaos of the city.</p>
        </div>
      ),
      icon: <Activity size={24} className="text-neon-blue" />
    },
    {
      title: "VITAL STATISTICS",
      targetId: "tutorial-stats",
      position: "bottom",
      content: (
        <div>
            <p className="mb-2">Monitor your resources closely:</p>
            <ul className="list-disc list-inside text-gray-300 text-xs space-y-1">
                <li><span className="text-neon-blue">Credits (CR)</span>: Used to build and upgrade.</li>
                <li><span className="text-neon-pink">Reputation</span>: Low rep triggers riots.</li>
                <li><span className="text-yellow-400">Energy</span>: Stations consume power. Don't blackout.</li>
            </ul>
        </div>
      ),
      icon: <Zap size={24} className="text-yellow-400" />
    },
    {
      title: "NETWORK VISUALIZATION",
      targetId: "tutorial-map",
      position: "bottom",
      content: "This holographic map displays your current network topology and active connections. Watch for disruptions here.",
      icon: <Map size={24} className="text-neon-green" />
    },
    {
      title: "EXPANSION PROTOCOLS",
      targetId: "tutorial-build",
      position: "top",
      content: "Construct new stations to increase revenue. Each station is procedurally generated by the AI Core.",
      icon: <Plus size={24} className="text-neon-blue" />
    },
    {
      title: "STATION MANAGEMENT",
      targetId: "tutorial-stations",
      position: "top",
      content: "Active stations appear here. Upgrade them to boost capacity and credits per tick. You can also eavesdrop on passengers.",
      icon: <Activity size={24} className="text-neon-pink" />
    },
    {
      title: "EVENT LOGS",
      targetId: "tutorial-events",
      position: "left",
      content: "The city is alive. Random events—storms, cyber-attacks, festivals—will appear here. They affect your stats in real-time.",
      icon: <AlertTriangle size={24} className="text-orange-400" />
    },
    {
      title: "DATA PERSISTENCE",
      targetId: "tutorial-data",
      position: "left",
      content: "The connection is unstable. Manually SAVE your progress to local storage to prevent data loss between sessions.",
      icon: <Save size={24} className="text-gray-400" />
    }
  ];

  // Effect to track target element position
  useEffect(() => {
    const updateRect = () => {
      const step = steps[currentStep];
      if (step.targetId) {
        const el = document.getElementById(step.targetId);
        if (el && el.offsetWidth > 0 && el.offsetHeight > 0) {
          // Add some padding to the rect
          const rect = el.getBoundingClientRect();
          setTargetRect(rect);
        } else {
          // Element not found or hidden (e.g. mobile), fallback to center
          setTargetRect(null);
        }
      } else {
        setTargetRect(null);
      }
    };

    // Run immediately and on resize/scroll
    updateRect();
    window.addEventListener('resize', updateRect);
    window.addEventListener('scroll', updateRect, true);

    return () => {
      window.removeEventListener('resize', updateRect);
      window.removeEventListener('scroll', updateRect, true);
    };
  }, [currentStep]);

  const handleNext = () => {
    if (currentStep < steps.length - 1) {
      setCurrentStep(prev => prev + 1);
    } else {
      onClose();
    }
  };

  const handlePrev = () => {
    if (currentStep > 0) {
      setCurrentStep(prev => prev - 1);
    }
  };

  const step = steps[currentStep];

  // Calculate Dialog Position based on targetRect and preferred position
  const getDialogStyle = () => {
    if (!targetRect) {
      // Center Position
      return {
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        maxWidth: '500px',
        width: '90%'
      };
    }

    // Relative Position
    const margin = 20;
    const dialogWidth = 320; // Approx width
    
    let top: number | string = 0;
    let left: number | string = 0;
    let transform = '';

    // Simple logic for now, can be enhanced with collision detection
    switch (step.position) {
      case 'top':
        top = targetRect.top - margin;
        left = targetRect.left + targetRect.width / 2;
        transform = 'translate(-50%, -100%)';
        break;
      case 'bottom':
        top = targetRect.bottom + margin;
        left = targetRect.left + targetRect.width / 2;
        transform = 'translate(-50%, 0)';
        break;
      case 'left':
        top = targetRect.top + targetRect.height / 2;
        left = targetRect.left - margin;
        transform = 'translate(-100%, -50%)';
        break;
      case 'right':
        top = targetRect.top + targetRect.height / 2;
        left = targetRect.right + margin;
        transform = 'translate(0, -50%)';
        break;
      default: // Fallback to bottom
        top = targetRect.bottom + margin;
        left = targetRect.left + targetRect.width / 2;
        transform = 'translate(-50%, 0)';
    }
    
    // Boundary checks (very basic)
    if (typeof left === 'number' && left < 160) { left = 160; transform = transform.replace('translate(-50%', 'translate(-50%').replace('translate(-100%', 'translate(-10%'); }

    return {
      top: top,
      left: left,
      transform: transform,
      width: '320px'
    };
  };

  return (
    <div className="fixed inset-0 z-[100] overflow-hidden text-white font-sans">
      
      {/* Backdrop / Spotlight Logic */}
      {targetRect ? (
        <>
          {/* Dimmed Backgrounds constructed around the target */}
          <div className="absolute bg-black/70 transition-all duration-300" style={{ top: 0, left: 0, right: 0, height: targetRect.top }} />
          <div className="absolute bg-black/70 transition-all duration-300" style={{ top: targetRect.bottom, left: 0, right: 0, bottom: 0 }} />
          <div className="absolute bg-black/70 transition-all duration-300" style={{ top: targetRect.top, left: 0, width: targetRect.left, height: targetRect.height }} />
          <div className="absolute bg-black/70 transition-all duration-300" style={{ top: targetRect.top, left: targetRect.right, right: 0, height: targetRect.height }} />
          
          {/* Target Highlight Border */}
          <div 
            className="absolute border-2 border-neon-blue shadow-[0_0_30px_rgba(0,243,255,0.5)] transition-all duration-300 rounded-md pointer-events-none animate-pulse-slow"
            style={{
              top: targetRect.top - 5,
              left: targetRect.left - 5,
              width: targetRect.width + 10,
              height: targetRect.height + 10
            }}
          />
        </>
      ) : (
        // Full backdrop for centered modal
        <div className="absolute inset-0 bg-black/80 backdrop-blur-sm" />
      )}

      {/* Dialog Card */}
      <div 
        className="absolute z-10 flex flex-col bg-neon-panel border border-neon-blue/50 rounded-xl shadow-[0_0_50px_rgba(0,0,0,0.8)] overflow-hidden transition-all duration-500 ease-in-out"
        style={getDialogStyle()}
      >
        {/* Header */}
        <div className="bg-black/40 p-3 border-b border-gray-700 flex justify-between items-center">
          <span className="text-xs font-mono text-neon-blue tracking-widest">SYSTEM_GUIDE // {currentStep + 1}/{steps.length}</span>
          <button onClick={onClose} className="text-gray-500 hover:text-white">
            <X size={16} />
          </button>
        </div>

        {/* Content */}
        <div className="p-5">
          <div className="flex items-center gap-3 mb-3">
            {step.icon}
            <h3 className="text-lg font-bold font-mono tracking-wide">{step.title}</h3>
          </div>
          <div className="text-sm text-gray-300 leading-relaxed min-h-[60px]">
            {step.content}
          </div>
        </div>

        {/* Footer / Controls */}
        <div className="p-3 bg-black/20 border-t border-gray-800 flex justify-between items-center">
           <button 
             onClick={handlePrev}
             disabled={currentStep === 0}
             className="text-gray-500 hover:text-white disabled:opacity-30 flex items-center gap-1 px-2 py-1 rounded transition-colors"
           >
             <ChevronLeft size={16} /> Back
           </button>

           <div className="flex gap-1">
             {steps.map((_, i) => (
               <div key={i} className={`h-1.5 w-1.5 rounded-full ${i === currentStep ? 'bg-neon-blue' : 'bg-gray-700'}`} />
             ))}
           </div>

           <button 
             onClick={handleNext}
             className="bg-neon-blue/10 hover:bg-neon-blue/20 text-neon-blue border border-neon-blue/50 px-4 py-1 rounded text-sm font-bold flex items-center gap-1 transition-all hover:shadow-[0_0_10px_rgba(0,243,255,0.2)]"
           >
             {currentStep === steps.length - 1 ? 'FINISH' : 'NEXT'} <ChevronRight size={16} />
           </button>
        </div>
      </div>

    </div>
  );
}
